Alexander Ruvalcaba
CPSC-25-10103
Proffesor Kanemoto
May 12, 2025

Merced Connect is a C++ desktop application designed to help users in the Merced community discover and manage local events. It features an intuitive command-line interface that allows users to browse, search, and view details about upcoming events. Having access to community event information shouldn't require users to search through multiple websites or flyers. Merced Connect is a small but useful application built to solve this problem by collecting local event data and displaying it in one easy-to-use interface. The goal was to create a tool that is simple, effective, and a foundation for something that could become much bigger with time.
Users can scroll through a list of events sorted by date, search for events by keyword, and view detailed information such as event names, dates, and locations. This is especially useful in a smaller city like Merced, where centralized event information can be hard to find. While the app is currently basic in appearance, it’s functional and serves as a strong prototype for future development.
The first major algorithm implemented in Merced Connect is the binary search algorithm. This algorithm is used for finding an event or resource by name from a sorted vector. Binary search significantly improves search performance compared to a linear search, especially as the data set grows. The algorithm operates by comparing the target name with the midpoint of the vector. If the midpoint does not match, the search range is halved accordingly, and the process continues until the target is found or the range is empty. The function “findEventIndexByName” demonstrates this technique and returns the index of the event in the vector if found. The binary search algorithm has a time complexity of O(log n), making it highly efficient for large, sorted data sets. 
The second algorithm used in Merced Connect is event sorting via “std::sort”, which internally applies a hybrid of quicksort and other efficient sorting methods depending on context. The function “sortEventsByDate” leverages this to order events chronologically. The key implementation involves using a lambda function to define how two Event objects should be compared—based on their date attribute. This approach achieves O(n log n) complexity and ensures that the event list is user-friendly and sorted correctly. It's worth noting that while “std::sort” may apply quicksort or introsort internally, its worst-case complexity is typically much better.
The third algorithm in Merced Connect deals with category and type filtering of events and resources using maps for fast access. Rather than iterating through the entire vector each time, I used unordered_map containers to associate categories or types with corresponding vectors of objects. This gives the filter functions near-constant time complexity, or O(1) average-case, thanks to the underlying hash table implementation. This algorithm was born out of a need for faster lookups when filtering. I realized that building the maps once and accessing them as needed would provide massive performance improvements. I originally planned to filter via linear search, but this proved inefficient. The hash map-based design is more scalable and reflects real-world best practices.
The primary data structures used in Merced Connect are vector and unordered_map, both from the C++ Standard Library. Vectors are ideal for storing the full list of events and resources because they offer dynamic resizing, fast access, and compatibility with standard algorithms like sort() and find(). For filtering and search operations, I used unordered_map to link categories and types to specific subsets of events or resources, allowing for fast, constant-time lookups. Organizing the project across multiple header and source files, such as Event.h, DataManager.h, and UserInterface.h also helped keep the code modular, readable, and easier to maintain as the app grew.
The user interface is command-line based and implemented in UserInterface.cpp. It is designed to be as intuitive as possible despite lacking graphical features. The interface displays a main menu with numbered options, handles user input validation, and calls functions in DataManager as needed. Functions such as displayMenu(), getUserSelection(), and displayEvents() create a straightforward user experience .One thing I want to call out is that I relied on ChatGPT for help building out UserInterface.cpp. It saved a ton of time by generating the menu layout and basic interaction logic. That said, I still went in and customized the flow, cleaned up formatting, and added input validation to make sure the app handled bad input without crashing..
One opportunity I discovered was in optimizing event filtering by using a map structure. Initially, I planned to loop through every event to find matches by category or type. However, I realized that maintaining a pre-categorized map would drastically reduce lookup time. This change made the filtering instantaneous for users and set the stage for scalable data expansion in the future.
One of the most frustrating issues I ran into during development wasn’t with the code itself, but with the project setup in Visual Studio Code. For a while, I couldn’t get the program to compile or run correctly because my launch.json and tasks.json files were missing the necessary configuration entirely. There were no compiler flags, source file listings, or output instructions like "-g", "DataManager.cpp", or "-o main" included in the tasks. As a result, the build process had nothing to work with. After doing some trial and error and with the help of my professor I was able to find the root issue. I manually added all the required fields to define which files to compile and how to generate the executable. Once those were in place, everything finally built and ran as expected. This taught me that getting the environment right is just as important as writing correct code.
Future improvements to Merced Connect include adding a graphical user interface with proper UI/UX, implementing user accounts for personalized event recommendations, supporting event submission by users, and integrating real-time online APIs for live event data. These changes would greatly improve the application and greatly enhance its value to the community.
